# Copilot guidance – new-system-upgrade-role
- Mission: repave a UniFi CloudKey Gen2 Plus from Debian 8 → 13, harden SSH, provision `/dev/sda` as `/home`, and bootstrap a target user with chezmoi-managed dotfiles.
- Entry point: `site.yml` runs two plays. Play 1 (`bootstrap`, `ssh_hardening`) connects with password auth (set by `ANSIBLE_PASSWORD` env). Play 2 (`system`, `storage`, `users`, `chezmoi`) reconnects using the generated `ssh_keys/root_ed25519` key and `/usr/bin/python3`.
- Upgrade flow: `roles/bootstrap/tasks/main.yml` chains raw `apt-get dist-upgrade` and reboots for 8→9→10→11, installs Python 3.9 + OpenSSH, then switches to native modules to reach Bookworm (12) and optional Trixie (13). Facts are reloaded via `meta: reset_connection` once Python is ready—preserve raw phases when touching early releases.
- SSH pivot: `roles/ssh_hardening` always ensures the control node holds `ssh_keys/root_ed25519(.pub)` with `openssh_keypair`, pushes it to `/root/.ssh/authorized_keys`, and deploys `sshd_config.j2` (PasswordAuthentication off, key-only). Any edits must keep the handler name `Restart sshd` intact.
- System prep: `roles/system` applies inventory hostnames, installs `isc-dhcp-*`, and enforces DHCP on `eth0`. Deviations (static net) should live here to keep later roles unchanged.
- Storage pattern: `roles/storage` reuses the `parted_res.changed` flag to gate destructive steps (`wipefs`, `swapoff`, `filesystem`). When extending storage logic, hook into that boolean instead of adding new fact names.
- User provisioning: `roles/users` expects inventory vars `target_user`, `public_key_file`, `private_key_file`, and optional `ssh_key_suffix`. It copies those files from the control node verbatim; keep paths readable from the playbook root and avoid fetching remote secrets mid-play.
- Password handling: the role generates a throwaway password using `lookup('password','/dev/null ...')` and hashes it via `openssl passwd -6` locally. Ensure any refactor retains local hashing (needed when remote Python is absent during upgrades).
- Chezmoi bootstrap: `roles/chezmoi` installs curl/git, exports `DEBIAN_FRONTEND=noninteractive`, then pipes the official installer to `sh` while impersonating `target_user`. It relies on `github_username` from inventory; guard against reruns by checking for `/home/{{ target_user }}/.local/share/chezmoi` if you add new tasks.
- Inventory contract: `inventory` is a static INI file; play 1 reads `ANSIBLE_PASSWORD` from the environment, so local runners typically execute `ANSIBLE_PASSWORD=... ansible-playbook -i inventory site.yml`. After SSH hardening, reruns succeed without the password if the key exists.
- Key artifacts: keep control-plane keys in `ssh_keys/`. Never assume they already exist—bootstrap regenerates them idempotently. When adding new keys, follow the same delegate-to-localhost pattern.
- Testing workflow: `ansible-playbook -i inventory site.yml -vv` is the canonical verification step. Because of mandatory reboots, prefer using `--limit cloudkey --forks 1` to avoid interleaved waits during development.
- Coding style: roles lean on built-in module namespaced calls (`ansible.builtin.*`) once Python 3 is available; raw shell is confined to pre-Python stages. Match that split when adding functionality.
- Safety tips: any task that can break connectivity (networking, storage) must be `become: yes` and idempotent. Reuse existing wait/reboot patterns (`wait_for`, `reboot`) so the control node pauses until SSH resumes.
